
\documentclass[submit]{ipsj}
%\documentclass{ipsj}

\usepackage{graphicx}
\usepackage{latexsym}

\def\Underline{\setbox0\hbox\bgroup\let\\\endUnderline}
\def\endUnderline{\vphantom{y}\egroup\smash{\underline{\box0}}\\}
\def\|{\verb|}


\setcounter{巻数}{59}
\setcounter{号数}{1}
\setcounter{page}{1}
% ここどうすれば？？
% ??
\受付{2019}{5}{31}
% \再受付{2015}{7}{16}   %省略可能
% \再再受付{2015}{7}{20} %省略可能
% \再再受付{2015}{11}{20} %省略可能
\採録{2019}{6}{21}
% 日付あってる？？



\begin{document}


\title{Code2Vec for C：C言語を対象としたコードの分散表現の獲得手法の提案}
% \etitle{Code2Vec for C：A proposal of a method for acquiring a distributed representation of code for C language}

\affiliate{IPSJ}{九州大学大学院 システム情報科学研究院\\
IPSJ, Faculty of Information Science and Electrical Engineering, Kyushu University}
\paffiliate{JU}{九州大学大学院 システム情報科学府\\
Graduate School of Information Science and Electrical Engineering, Kyushu University}
\paffiliate{F}{富士通九州ネットワークテクノロジーズ(株)\\
Fujitsu Kyushu Network Technologies Limited}



\author{檜枝 琴里}{Kotori Hieda}{JU}[hieda@f.ait.kyushu-u.ac.jp]
\author{久住 憲嗣}{Kenji Hisazumi}{IPSJ}[nel@slrc.kyushu-u.ac.jp]
\author{矢川 博文}{Hirofumi Yagawa}{F}
\author{福田 晃}{Akira Fukuda}{IPSJ}[gakkai.jiro@ipsj.or.jp]

\begin{abstract}
プログラムコードの分散表現を得るための手法としてCode2Vecが存在する．これはプログラムコードの埋め込みベクトルを得るために，メソッド本体などのコード片の機能を表すラベルを予測するタスクで学習するものである．これによりプログラムコードにおいてもコード片の意味を考慮した分散表現を得ることが出来る．Code2VecはJavaやCなどのオブジェクト指向プログラムを対象としているが，組込みシステム開発ではオブジェクト指向言語ではないC言語を使用していることが多い．そのため，Code2Vecの手法を適用するために，C言語からの特徴量の抽出手法が必要であることや，関数名等の命名方法がオブジェクト指向言語と異なるためラベルの予測が困難といった課題がある．そこで本研究ではCode2Vecの手法をC言語プログラムにも対応可能にすべく，C言語からの特徴量の抽出手法を提案し，関数名等をオブジェクト指向言語と同様のモジュール名と機能名に分解するためのITF-DF手法を提案する．
\end{abstract}


\begin{jkeyword}
Code2Vec，C言語，自動推定，コード片，ITF-DF，機械学習
\end{jkeyword}


\maketitle

%1
\section{序論}
自然言語処理ではword2vec[引用]などの意味を考慮した分散表現を得る方法が提案されており様々な応用が展開している。プログラムコードにおいても同様の分散表現を得る手法を使用することにより、ソフトウェア開発を多様な側面から支援することができると考えられるが、手法、応用の両面ともに発展の余地がある。プログラムコードの分散表現を得る手法としてcode2vec[引用]が提案されている。Code2Vecとはプログラムコードの分散表現を得るための手法であり，コード片を高次元の実数ベクトルとして表すことで，コード片やそれ同士の関連性を数値的に表現することができる．このCode2Vecは現状ではJavaやC#等のオブジェクト指向プログラム言語を対象としている。しかしながら、組込みシステムなどで多く使用されているC言語はオブジェクト指向言語でないため，Code2VecをC言語にそのまま適用できない．具体的には～～～という課題がある。
そこで本研究ではこの課題を解決すべく、TF-IDF (…) を関数名に適用しモジュール固有名と操作名とを選別し、操作名のみを学習する手法を提案する。TF-IDFは単語の重要度を示す指標であり，{log (文書Aにおける単語Xの出現頻度) / (文書Aにおける全単語の出現頻度の和)} * {(全文書数) / (単語Xを含む文書数)} として計算したものである．これにより，ある文書の中での出現頻度は低いが様々な文書を通して見ると出現頻度が高い単語の重要度が高くなる．[だからなにが起こるかを具体的に書く]。[ここの文がよくわからない]このITF-DF手法において単語をコード片，文書をプログラムコード全体とすることでコード片の重要度を決定する．こうすることで真に重要な部分を学習することとなり，関数名推定の精度向上を図ることが可能となる．\\
具体的には，C言語で記述されたプログラムコードを？？個用意し，ITF-DF手法を用いて重み付けをした関数名を学習する．学習したコード片に基づきC言語にも対応させたCode2Vecを用いることで，コード片をベクトルとし，関連のあるコード片同士を紐付ける．評価の方法として，評価をするためのプログラムコードを用意し，その中の関数名と，関数名推定を行った結果とを照らし合わせ，元の関数名との適合率を表す．


% プログラムコードにおける関数名や変数名はその作成者により定義づけられているが，中には関数の内容と関数名が適切に対応づけられていないものが存在し，そのプログラムコードを読んだ第三者を混乱に招きかねない問題がある．したがって適切な関数名や変数名を提案する手法としてCode2Vecを用いたい．
% Code2Vecとはプログラムコードの分散表現を得るための手法であり，コード片を高次元の実数ベクトルとして表すことで，コード片やそれ同士の関連性を数値的に表現することができる．このCode2Vecはオブジェクト指向プログラミングを対象としているが，組込みシステムなどで多く使用されているC言語はオブジェクト指向言語でないため，Code2VecをC言語を対象として使用したい際，新たな手法を検討しなければならない．\\
% 本稿ではC言語においてもCode2Vecを適応させる方法として，ITF-DF (Inverse Term Frequency - Document Frequency) 手法を用いた．これは単語の重要度を示す指標であり，{log (文書Aにおける単語Xの出現頻度) / (文書Aにおける全単語の出現頻度の和)} * {(全文書数) / (単語Xを含む文書数)} として計算したものである．これにより，ある文書の中での出現頻度は低いが様々な文書を通して見ると出現頻度が高い単語の重要度が高くなる．このITF-DF手法において単語をコード片，文書をプログラムコード全体とすることでコード片の重要度を決定する．こうすることで真に重要な部分を学習することとなり，関数名推定の精度向上を図ることが可能となる．\\
% 具体的には，C言語で記述されたプログラムコードを？？個用意し，ITF-DF手法を用いて重み付けをした関数名を学習する．学習したコード片に基づきC言語にも対応させたCode2Vecを用いることで，コード片をベクトルとし，関連のあるコード片同士を紐付ける．評価の方法として，評価をするためのプログラムコードを用意し，その中の関数名と，関数名推定を行った結果とを照らし合わせ，元の関数名との適合率を表す．

% \footnotetext{本文は実際には論文誌ジャーナル編集委員会で作成したものである．}




%2
\section{解析手法}
本稿では，C言語で書かれているプログラムコードを(?)個用意した．その中の関数名を，Code2Vecを用いて分散表現し，モジュール名と機能名に分類した．Code2VecはC言語のような非オブジェクト指向言語を対象としていないため，C言語等向けのコンパイラフロントエンドLのClangとバックエンドのLLVMを用いてC言語にもCode2Vecを応用できるようにした．具体的には〜〜〜〜〜？？？

モジュール名と機能名に分類した関数名を，ITF-DF手法により，ある文書の中での出現頻度は低いが様々な文書を通して見ると出現頻度が高い単語の重要度が高くなるように，閾値を設定して重み付けをした．さらにモジュール名と機能名に分類し重み付けをした関数名を，関数の内容と紐づけて学習した．これを辞書として用意し，関数の内容からその関数名として適切だと思われるものを，辞書から選び提案する．

学習したデータを基に，テスト用に用意した関数の内容をシステムに読み込ませ，その関数名を推定させる．元の関数名との適合率を評価の基準として表す．

%データは何個用意する。ITF-DF手法を使って関数名などをモジュール名と機能名に分解して学習する。学習したらテストデータでうまくいくか試してみる。




%3
\section{結果}
表~\ref{table??} に結果を示す．
表は関数名推定結果の一部である。表より，ITF-DF手法を用いていない時と比較し，ITF-DF手法を用いた時の方が関数名推定の精度が？\%向上していることがわかる．
% 間違えてるのもあるけどなんとなくうまくいった。
% 〜〜(推定結果の図か表)〜〜

%4
\section{結論}
今回，我々はLLVMとClangを用いてCode2VecをC言語に対応可能な状態にした．またそれを適用する事でC言語の関数名をモジュール名と機能名に分類し，ITF-DF手法により重み付けしたものを機械学習することで関数名推定の精度を向上を試みた．結果，ITF-DF手法を用いることで，汎用的に用いられれいるモジュール名を抜き出すことが可能となり，関数名推定の精度が向上することがわかった．\\
今後の予定として，より多くのテストデータを用いての詳細な評価を試みる．また現在よりも更に精度が向上するITF-DF手法の計算方法を模索する．それを再度評価することで，C言語特有の拡張が可能となることを期待する．


% うまくいった。ラッキー。

%5
\section{参考文献}






% \begin{biography}
% \profile{m,E}{情報 太郎}{1970年生．1992年情報処理大学理学部情報科学科卒業．
% 1994年同大学大学院修士課程修了．同年情報処理学会入社．オンライン出版の研究
% に従事．電子情報通信学会，IEEE，ACM 各会員．}
% %
% \profile{n}{処理 花子}{1960年生．1982年情報処理大学理学部情報科学科卒業．
% 1984年同大学大学院修士課程修了．1987年同博士課程修了．理学博士．1987年情報処
% 理大学助手．1992年架空大学助教授．1997年同大教授．オンライン出版の研究
% に従事．2010年情報処理記念賞受賞．電子情報通信学会，IEEE，IEEE-CS，ACM
% 各会員．}
% %
% \profile{h,L}{学会 次郎}{1950年生．1974年架空大学大学院修士課程修了．
% 1987年同博士課程修了．工学博士．1977年架空大学助手．1992年情報処理大学助
% 教授．1987年同大教授．2000年から情報処理学会顧問．オンライン出版の研究
% に従事．2010年情報処理記念賞受賞．情報処理学会理事．電子情報通信学会，
% IEEE，IEEE-CS，ACM 各会員．}
% \end{biography}



\end{document}
